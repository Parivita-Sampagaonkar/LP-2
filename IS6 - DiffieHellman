Code:
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Diffieâ€“Hellman Demo</title>
  <style>
    body { font-family: sans-serif; max-width: 600px; margin: 2em auto; }
    label, button { display: block; margin: 0.5em 0; }
    span { font-weight: bold; }
  </style>
</head>
<body>
  <h1>Diffieâ€“Hellman Key Exchange</h1>

  <p>Prime (p): <span id="prime">23</span></p>
  <p>Generator (g): <span id="generator">5</span></p>

  <label>
    Your secret (a):
    <input type="number" id="secretA" value="6" min="1">
  </label>

  <button id="compute">Generate Public Keys & Shared Secret</button>

  <h2>Results</h2>
  <p>Your public value (A = g<sup>a</sup> mod p): <span id="publicA">â€“</span></p>
  <p>Bobâ€™s secret (b, chosen randomly): <span id="secretB">â€“</span></p>
  <p>Bobâ€™s public value (B = g<sup>b</sup> mod p): <span id="publicB">â€“</span></p>
  <p>Your shared secret (s = B<sup>a</sup> mod p): <span id="sharedA">â€“</span></p>
  <p>Bobâ€™s shared secret (s = A<sup>b</sup> mod p): <span id="sharedB">â€“</span></p>

  <script>
    // 1. Fixed parameters (small for demo; real use needs large safe primes!)
    const p = 23n;
    const g = 5n;

    // 2. Fast modular exponentiation (base^exp mod m) using BigInt
    function modPow(base, exp, m) {
      let result = 1n;
      base %= m;
      while (exp > 0n) {
        if (exp & 1n) result = (result * base) % m;
        exp >>= 1n;
        base = (base * base) % m;
      }
      return result;
    }

    document
      .getElementById("compute")
      .addEventListener("click", () => {
        // --- Aliceâ€™s side (user) ---
        const a = BigInt(document.getElementById("secretA").value);
        const A = modPow(g, a, p);               // Aliceâ€™s public = g^a mod p
        document.getElementById("publicA").innerText = A.toString();

        // --- Bobâ€™s side (JavaScript) ---
        // Pick b randomly in [1, p-2]
        const b = BigInt( Math.floor(Math.random() * Number(p - 2n)) + 1 );
        document.getElementById("secretB").innerText = b.toString();
        const B = modPow(g, b, p);               // Bobâ€™s public = g^b mod p
        document.getElementById("publicB").innerText = B.toString();

        // --- Shared secret computation ---
        // Alice computes s = B^a mod p
        const sA = modPow(B, a, p);
        // Bob computes   s = A^b mod p
        const sB = modPow(A, b, p);

        document.getElementById("sharedA").innerText = sA.toString();
        document.getElementById("sharedB").innerText = sB.toString();
      });
  </script>
</body>
</html>


Output:
Enter Aliceâ€™s secret (a):

Copy
Edit
6
Click â€œGenerate Public Keys & Shared Secretâ€ and you might get:

Field	Value
Your public value (A = 5â¶ mod 23)	8
Bobâ€™s secret (b, random in [1,21])	15
Bobâ€™s public value (B = 5Â¹âµ mod 23)	19
Your shared secret (s = 19â¶ mod 23)	2
Bobâ€™s shared secret (s = 8Â¹âµ mod 23)	2


Explanation of Code Logic:
Below is a walkthrough of every part of the HTMLâ€‰+â€‰JavaScript Diffieâ€“Hellman demo, explaining what each line or block does and why itâ€™s needed.

1. The HTML Structure
html
Copy
Edit
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Diffieâ€“Hellman Demo</title>
  <style>
    body { font-family: sans-serif; max-width: 600px; margin: 2em auto; }
    label, button { display: block; margin: 0.5em 0; }
    span { font-weight: bold; }
  </style>
</head>
<body>
  <h1>Diffieâ€“Hellman Key Exchange</h1>

  <p>Prime (p): <span id="prime">23</span></p>
  <p>Generator (g): <span id="generator">5</span></p>

  <label>
    Your secret (a):
    <input type="number" id="secretA" value="6" min="1">
  </label>

  <button id="compute">Generate Public Keys & Shared Secret</button>

  <h2>Results</h2>
  <p>Your public value (A = g<sup>a</sup> mod p): <span id="publicA">â€“</span></p>
  <p>Bobâ€™s secret (b, chosen randomly): <span id="secretB">â€“</span></p>
  <p>Bobâ€™s public value (B = g<sup>b</sup> mod p): <span id="publicB">â€“</span></p>
  <p>Your shared secret (s = B<sup>a</sup> mod p): <span id="sharedA">â€“</span></p>
  <p>Bobâ€™s shared secret (s = A<sup>b</sup> mod p): <span id="sharedB">â€“</span></p>
<span id="prime">23</span> and <span id="generator">5</span>
We hard-code small prime p=23 and generator g=5 for clarity. In a real system these would be very large.

<input type="number" id="secretA" â€¦>
This is Aliceâ€™s secret 
ğ‘
a. The user enters a positive integer.

<button id="compute">â€¦</button>
A button that, when clicked, runs our JavaScript to simulate Bobâ€™s side and compute everything.

Result placeholders (<span id="publicA">, etc.)
Empty spans where weâ€™ll insert the computed values.

2. The JavaScript: Modular Exponentiation
js
Copy
Edit
<script>
  // 1. Fixed parameters (small for demo; real use needs large safe primes!)
  const p = 23n;
  const g = 5n;

  // 2. Fast modular exponentiation (base^exp mod m) using BigInt
  function modPow(base, exp, m) {
    let result = 1n;
    base %= m;
    while (exp > 0n) {
      if (exp & 1n)            // if the low bit of exp is 1
        result = (result * base) % m;
      exp >>= 1n;              // shift exp right by 1 bit
      base = (base * base) % m;
    }
    return result;
  }
23n, 5n
The trailing n makes these JavaScript BigInt literals, so we can do arbitraryâ€length integer math without overflow.

modPow
Efficiently computes base^exp mod m via â€œexponentiation by squaring.â€

We loop while exp > 0.

If the current bit of exp is 1, multiply result by base (mod m).

Square base each iteration and shift exp right one bit.

This runs in O(log exp) multiplications instead of exp multiplications.

3. Wiring Up the Button
js
Copy
Edit
  document
    .getElementById("compute")
    .addEventListener("click", () => {
      // --- Aliceâ€™s side (user) ---
      const a = BigInt(document.getElementById("secretA").value);
      const A = modPow(g, a, p);               // A = g^a mod p
      document.getElementById("publicA").innerText = A.toString();

      // --- Bobâ€™s side (JavaScript) ---
      // Pick b randomly in [1, p-2]
      const b = BigInt(
        Math.floor(Math.random() * Number(p - 2n)) + 1
      );
      document.getElementById("secretB").innerText = b.toString();
      const B = modPow(g, b, p);               // B = g^b mod p
      document.getElementById("publicB").innerText = B.toString();

      // --- Shared secret computation ---
      const sA = modPow(B, a, p);              // Alice computes s = B^a mod p
      const sB = modPow(A, b, p);              // Bob   computes s = A^b mod p

      document.getElementById("sharedA").innerText = sA.toString();
      document.getElementById("sharedB").innerText = sB.toString();
    });
</script>
Reading Aliceâ€™s secret

js
Copy
Edit
const a = BigInt(document.getElementById("secretA").value);
We grab the userâ€™s number and convert it to a BigInt.

Aliceâ€™s public value

js
Copy
Edit
const A = modPow(g, a, p);
Computes A = gáµƒ mod p, then inserts it into the page.

Bobâ€™s secret (b)

js
Copy
Edit
const b = BigInt(
  Math.floor(Math.random() * Number(p - 2n)) + 1
);
We pick an integer b uniformly at random from 1 to pâ€“2.

Converting pâ€“2n to a Number for the random routine is safe here since p is small.

Bobâ€™s public value

js
Copy
Edit
const B = modPow(g, b, p);
Computes B = gáµ‡ mod p and displays it.

Shared secret

Aliceâ€™s view: sA = Báµƒ mod p

Bobâ€™s view: sB = Aáµ‡ mod p
Both yield the same integer s, even though Alice never learns b and Bob never learns a. We display both to confirm the match.

4. Putting It All Together
Security principle: Discrete exponentiation mod p is easy, but recovering a or b from A = gáµƒ mod p is a â€œhardâ€ discrete log problem (for large p).

Browser demo: We choose tiny values so the math is immediate and visible.

BigInt: Allows JavaScript to handle arbitrarily large integersâ€”essential in real DH where p might be 2048 bits or more.

By structuring the code this wayâ€”clear separation of Aliceâ€™s steps, Bobâ€™s steps, and the shared-secret checkâ€”you can see exactly how Diffieâ€“Hellman lets two parties agree on a secret over an insecure channel without ever transmitting that secret itself.



Theory:
1. Modular Arithmetic Basics
Integers Modulo p

We work in the set { 0, 1, 2, â€¦, pâ€“1 } with arithmetic defined â€œmod p.â€

When you add, subtract or multiply, you reduce the result by taking the remainder on division by p.

Prime Modulus

Choosing p prime ensures that every nonzero element has a unique multiplicative inverse.

The set of nonzero residues mod p, written ğ™â‚š* = { 1, 2, â€¦, pâ€“1 }, forms a cyclic group under multiplication.

Primitive Root (Generator) g

A generator g is an element of ğ™â‚š* whose successive powers â€œhitâ€ every element of ğ™â‚š* before repeating.

In other words, { gÂ¹, gÂ², â€¦, gáµ–â»Â¹ } mod p = all nonzero residues.

This property underpins the Diffieâ€“Hellman exchange.

2. One-Way Functions: Exponentiation vs. Discrete Log
Fast Exponentiation

Computing gáµƒ mod p (even for large exponents) is efficient via â€œexponentiation by squaringâ€ (our modPow function).

Complexity is on the order of O(log a) modular multiplications.

Discrete Logarithm Problem

Given p, g, and A = gáµƒ mod p, recovering a is believed to be computationally hard when p is large (hundreds or thousands of bits).

No known polynomial-time algorithm on classical computersâ€”this asymmetry makes exponentiation a one-way function.

3. The Diffieâ€“Hellman Key Exchange Protocol
Public Parameters

Prime p and generator g are public and can be known by everyone (including attackers).

Private Secrets

Alice picks a secret a (1 â‰¤ a â‰¤ pâ€“2).

Bob picks a secret b (1 â‰¤ b â‰¤ pâ€“2).

Public Values

Alice computes A = gáµƒ mod p and sends A to Bob.

Bob computes B = gáµ‡ mod p and sends B to Alice.

Shared Secret Computation

Alice computes s = Báµƒ mod p = (gáµ‡)áµƒ mod p = gáµƒáµ‡ mod p

Bob computes s = Aáµ‡ mod p = (gáµƒ)áµ‡ mod p = gáµ‡áµƒ mod p

Because exponentiation commutes in the exponent, both get the same s without ever sharing a or b directly.

4. Why Itâ€™s Secure
Eavesdropperâ€™s View

An attacker sees p, g, A = gáµƒ, and B = gáµ‡.

To compute s = gáµƒáµ‡, they would need either a or bâ€”i.e. solve the discrete log problem on A or B.

Ephemeral Secrets

In practice, a and b should be drawn fresh for each session (â€œephemeralâ€) so past communications remain secure even if one sessionâ€™s secret leaks.

Man-in-the-Middle Risk

DH by itself does not authenticate partiesâ€”an active attacker could substitute their own public values unless you pair DH with signatures or a PKI.

5. Implementation Details in the Demo
BigInt Arithmetic

JavaScriptâ€™s BigInt type lets us handle arbitrarily large integers without overflowâ€”critical for real DH where p is hundreds of bits.

modPow Function

js
Copy
Edit
function modPow(base, exp, m) { â€¦ }
Implements exponentiation by squaring:

Initialize result = 1.

While exp > 0:

If the current low bit of exp is 1, result = (result * base) % m.

Square base â†’ (base * base) % m.

Shift exp right by one bit.

Returns result = baseáµ‰á¶œ mod m in O(log exp) steps.

Randomness for Bobâ€™s Secret

Although our demo uses a simple Math.random(), a production system must use a cryptographically secure RNG (e.g. window.crypto.getRandomValues) to pick b.

6. Practical Considerations
Parameter Sizes

Real-world DH uses primes p of at least 2048 bits (â‰ˆ 617 decimal digits) to resist index-calculus attacks.

Generators and primes are often chosen together to ensure the group has a large prime-order subgroup, mitigating small-subgroup attacks.

Authenticated Key Exchange

To prevent active man-in-the-middle attacks, you wrap DH in a handshake that verifies identities (e.g. TLS uses certified digital signatures).

Forward Secrecy

Ephemeral DH keys ensure that compromise of long-term keys doesnâ€™t expose past session keys.

In a Nutshell
Diffieâ€“Hellman leverages the asymmetry between:

Easy: computing exponentials mod p (gáµƒ mod p), and

Hard: computing discrete logarithms (recovering a from gáµƒ mod p),

to let two parties agree on a shared secret without ever transmitting that secret directly. The demoâ€™s HTMLâ€‰+â€‰JS code transparently mirrors those stepsâ€”choosing secrets, exponentiating, and verifying that both sides arrive at the same shared keyâ€”while abstracting away the low-level number-theory into a concise modPow helper.
